name: Nightly Build with Ephemeral EC2

on:
  schedule:
    - cron: "0 0 * * *"  # Nightly at 00:00 UTC
  workflow_dispatch:

jobs:
  build-test-integration-deploy:
    runs-on: ubuntu-latest

    steps:
      # 1. Check out code
      - name: Checkout
        uses: actions/checkout@v4

      # 2. Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # 3. Login to Amazon ECR
      - name: Login to ECR
        run: |
          aws ecr get-login-password --region us-east-1 \
            | docker login --username AWS --password-stdin ${{ secrets.AWS_ECR_URL }}

      # 4. Build & Test Backend
      - name: Build & Test Backend
        run: |
          docker build -t backend-test -f backend/Dockerfile backend
          docker run --rm backend-test npm test

      # 5. Build & Test Frontend
      - name: Build & Test Frontend
        run: |
          docker build -t frontend-test -f frontend/Dockerfile frontend
          docker run --rm frontend-test npm test

      # 6. Build & Push Images to ECR
      - name: Build & Push Backend
        run: |
          docker build -t ${{ secrets.AWS_ECR_URL }}/backend:latest -f backend/Dockerfile backend
          docker push ${{ secrets.AWS_ECR_URL }}/backend:latest

      - name: Build & Push Frontend
        run: |
          docker build -t ${{ secrets.AWS_ECR_URL }}/frontend:latest -f frontend/Dockerfile frontend
          docker push ${{ secrets.AWS_ECR_URL }}/frontend:latest

      # 7. Create Temp EC2 for Integration Testing
      - name: Create Temp EC2
        id: create_temp_ec2
        run: |
          set -e
          # Launch a t2.micro (or any type) in your VPC
          # NOTE: Provide your own AMI, key name, subnet, and security group
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0123456789abcdef0 \
            --instance-type t2.micro \
            --key-name ${{ secrets.EC2_KEY_NAME }} \
            --security-group-ids sg-123456789 \
            --subnet-id subnet-123456789 \
            --count 1 \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=Temp-Integration-EC2}]' \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "Waiting for instance $INSTANCE_ID to be running..."
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          echo "Instance ID: $INSTANCE_ID"
          echo "Public IP: $PUBLIC_IP"

          # Save for later steps
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

      # 8. Install Docker & Docker Compose, Run Integration Tests
      - name: Integration Test on Temp EC2
        run: |
          set -e
          echo "Connecting to ephemeral EC2 at $PUBLIC_IP"
          
          # Copy your SSH private key from secrets into a file
          echo "${{ secrets.EC2_SSH_KEY }}" > temp_key.pem
          chmod 600 temp_key.pem
          
          # Install Docker & Compose, run docker-compose up, do smoke tests
          ssh -o StrictHostKeyChecking=no -i temp_key.pem ec2-user@${{ env.PUBLIC_IP }} << 'EOF'
            sudo yum update -y
            sudo yum install -y docker git
            sudo service docker start
            sudo usermod -aG docker ec2-user

            # Install Docker Compose
            sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-\$(uname -s)-\$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose

            # Pull images
            docker pull ${{ secrets.AWS_ECR_URL }}/backend:latest
            docker pull ${{ secrets.AWS_ECR_URL }}/frontend:latest

            # Create docker-compose.yml
            cat << 'COMPOSE' > docker-compose.yml
            version: '3'
            services:
              backend:
                image: ${{ secrets.AWS_ECR_URL }}/backend:latest
                container_name: backend
                ports:
                  - "8800:8800"
              frontend:
                image: ${{ secrets.AWS_ECR_URL }}/frontend:latest
                container_name: frontend
                ports:
                  - "3000:3000"
            COMPOSE

            docker-compose up -d
            sleep 20  # wait for containers to start

            # Smoke test backend (check if "welcome zhunan" or something similar)
            RESPONSE_BACKEND=\$(curl -s http://localhost:8800/login || true)
            if [[ \$RESPONSE_BACKEND != *"welcome zhunan"* ]]; then
              echo "Smoke test failed. 'welcome zhunan' not found in backend response."
              docker-compose down
              exit 1
            fi

            # Smoke test frontend
            RESPONSE_FRONTEND=\$(curl -s http://localhost:3000 || true)
            if [[ \$RESPONSE_FRONTEND != *"React App"* ]]; then
              echo "Smoke test failed. 'React App' not found in frontend."
              docker-compose down
              exit 1
            fi

            # All tests pass
            docker-compose down
          EOF

      # 9. Remove Images from ECR if QA Fails
      - name: Remove Images from ECR on QA Failure
        if: failure()
        run: |
          echo "QA deployment failed. Removing images from ECR..."
          aws ecr batch-delete-image \
            --repository-name backend \
            --image-ids imageTag=latest || true
          aws ecr batch-delete-image \
            --repository-name frontend \
            --image-ids imageTag=latest || true

      # 10. Terminate Temp EC2
      - name: Terminate Temp EC2
        if: always()
        run: |
          set -e
          aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ID }}
          echo "Waiting for instance ${{ env.INSTANCE_ID }} to terminate..."
          aws ec2 wait instance-terminated --instance-ids ${{ env.INSTANCE_ID }}
          echo "Temp EC2 terminated."

      # 11. If Integration Succeeds, Deploy to QA
      - name: Deploy to QA
        if: success()
        run: |
          ssh -o StrictHostKeyChecking=no -i temp_key.pem ec2-user@${{ secrets.QA_EC2_IP }} << 'EOF'
            docker pull ${{ secrets.AWS_ECR_URL }}/backend:latest
            docker pull ${{ secrets.AWS_ECR_URL }}/frontend:latest
            docker compose up -d
          EOF

